# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from monitor_msgs/InteractionReport.msg. Do not edit."""

import codecs
import sys

python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import monitor_msgs.msg
import std_msgs.msg


class InteractionReport(genpy.Message):
    _md5sum = "8450cbcbe5a9fa2d33ff330699603fec"
    _type = "monitor_msgs/InteractionReport"
    _has_header = True  # flag to mark the presence of a Header object
    _full_text = """std_msgs/Header header
string period
uint32 total_interactions
DestinationStat[] top_destinations
float32 speech_recognition_rate
float32 average_interaction_time
float32 distance_traveled
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: monitor_msgs/DestinationStat
string name
uint32 count"""
    __slots__ = [
        "header",
        "period",
        "total_interactions",
        "top_destinations",
        "speech_recognition_rate",
        "average_interaction_time",
        "distance_traveled",
    ]
    _slot_types = [
        "std_msgs/Header",
        "string",
        "uint32",
        "monitor_msgs/DestinationStat[]",
        "float32",
        "float32",
        "float32",
    ]

    def __init__(self, *args, **kwds):
        """
        Constructor. Any message fields that are implicitly/explicitly
        set to None will be assigned a default value. The recommend
        use is keyword arguments as this is more robust to future message
        changes.  You cannot mix in-order arguments and keyword arguments.

        The available fields are:
           header,period,total_interactions,top_destinations,speech_recognition_rate,average_interaction_time,distance_traveled

        :param args: complete set of field values, in .msg order
        :param kwds: use keyword arguments corresponding to message field names
        to set specific fields.
        """
        if args or kwds:
            super(InteractionReport, self).__init__(*args, **kwds)
            # message fields cannot be None, assign default values for those that are
            if self.header is None:
                self.header = std_msgs.msg.Header()
            if self.period is None:
                self.period = ""
            if self.total_interactions is None:
                self.total_interactions = 0
            if self.top_destinations is None:
                self.top_destinations = []
            if self.speech_recognition_rate is None:
                self.speech_recognition_rate = 0.0
            if self.average_interaction_time is None:
                self.average_interaction_time = 0.0
            if self.distance_traveled is None:
                self.distance_traveled = 0.0
        else:
            self.header = std_msgs.msg.Header()
            self.period = ""
            self.total_interactions = 0
            self.top_destinations = []
            self.speech_recognition_rate = 0.0
            self.average_interaction_time = 0.0
            self.distance_traveled = 0.0

    def _get_types(self):
        """
        internal API method
        """
        return self._slot_types

    def serialize(self, buff):
        """
        serialize message into buffer
        :param buff: buffer, ``StringIO``
        """
        try:
            _x = self
            buff.write(
                _get_struct_3I().pack(
                    _x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs
                )
            )
            _x = self.header.frame_id
            length = len(_x)
            if python3 or type(_x) == unicode:
                _x = _x.encode("utf-8")
                length = len(_x)
            buff.write(struct.Struct("<I%ss" % length).pack(length, _x))
            _x = self.period
            length = len(_x)
            if python3 or type(_x) == unicode:
                _x = _x.encode("utf-8")
                length = len(_x)
            buff.write(struct.Struct("<I%ss" % length).pack(length, _x))
            _x = self.total_interactions
            buff.write(_get_struct_I().pack(_x))
            length = len(self.top_destinations)
            buff.write(_struct_I.pack(length))
            for val1 in self.top_destinations:
                _x = val1.name
                length = len(_x)
                if python3 or type(_x) == unicode:
                    _x = _x.encode("utf-8")
                    length = len(_x)
                buff.write(struct.Struct("<I%ss" % length).pack(length, _x))
                _x = val1.count
                buff.write(_get_struct_I().pack(_x))
            _x = self
            buff.write(
                _get_struct_3f().pack(
                    _x.speech_recognition_rate,
                    _x.average_interaction_time,
                    _x.distance_traveled,
                )
            )
        except struct.error as se:
            self._check_types(
                struct.error(
                    "%s: '%s' when writing '%s'"
                    % (type(se), str(se), str(locals().get("_x", self)))
                )
            )
        except TypeError as te:
            self._check_types(
                ValueError(
                    "%s: '%s' when writing '%s'"
                    % (type(te), str(te), str(locals().get("_x", self)))
                )
            )

    def deserialize(self, str):
        """
        unpack serialized message in str into this message instance
        :param str: byte array of serialized message, ``str``
        """
        if python3:
            codecs.lookup_error("rosmsg").msg_type = self._type
        try:
            if self.header is None:
                self.header = std_msgs.msg.Header()
            if self.top_destinations is None:
                self.top_destinations = None
            end = 0
            _x = self
            start = end
            end += 12
            (
                _x.header.seq,
                _x.header.stamp.secs,
                _x.header.stamp.nsecs,
            ) = _get_struct_3I().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
                self.header.frame_id = str[start:end].decode("utf-8", "rosmsg")
            else:
                self.header.frame_id = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
                self.period = str[start:end].decode("utf-8", "rosmsg")
            else:
                self.period = str[start:end]
            start = end
            end += 4
            (self.total_interactions,) = _get_struct_I().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            self.top_destinations = []
            for i in range(0, length):
                val1 = monitor_msgs.msg.DestinationStat()
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                start = end
                end += length
                if python3:
                    val1.name = str[start:end].decode("utf-8", "rosmsg")
                else:
                    val1.name = str[start:end]
                start = end
                end += 4
                (val1.count,) = _get_struct_I().unpack(str[start:end])
                self.top_destinations.append(val1)
            _x = self
            start = end
            end += 12
            (
                _x.speech_recognition_rate,
                _x.average_interaction_time,
                _x.distance_traveled,
            ) = _get_struct_3f().unpack(str[start:end])
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e)  # most likely buffer underfill

    def serialize_numpy(self, buff, numpy):
        """
        serialize message with numpy array types into buffer
        :param buff: buffer, ``StringIO``
        :param numpy: numpy python module
        """
        try:
            _x = self
            buff.write(
                _get_struct_3I().pack(
                    _x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs
                )
            )
            _x = self.header.frame_id
            length = len(_x)
            if python3 or type(_x) == unicode:
                _x = _x.encode("utf-8")
                length = len(_x)
            buff.write(struct.Struct("<I%ss" % length).pack(length, _x))
            _x = self.period
            length = len(_x)
            if python3 or type(_x) == unicode:
                _x = _x.encode("utf-8")
                length = len(_x)
            buff.write(struct.Struct("<I%ss" % length).pack(length, _x))
            _x = self.total_interactions
            buff.write(_get_struct_I().pack(_x))
            length = len(self.top_destinations)
            buff.write(_struct_I.pack(length))
            for val1 in self.top_destinations:
                _x = val1.name
                length = len(_x)
                if python3 or type(_x) == unicode:
                    _x = _x.encode("utf-8")
                    length = len(_x)
                buff.write(struct.Struct("<I%ss" % length).pack(length, _x))
                _x = val1.count
                buff.write(_get_struct_I().pack(_x))
            _x = self
            buff.write(
                _get_struct_3f().pack(
                    _x.speech_recognition_rate,
                    _x.average_interaction_time,
                    _x.distance_traveled,
                )
            )
        except struct.error as se:
            self._check_types(
                struct.error(
                    "%s: '%s' when writing '%s'"
                    % (type(se), str(se), str(locals().get("_x", self)))
                )
            )
        except TypeError as te:
            self._check_types(
                ValueError(
                    "%s: '%s' when writing '%s'"
                    % (type(te), str(te), str(locals().get("_x", self)))
                )
            )

    def deserialize_numpy(self, str, numpy):
        """
        unpack serialized message in str into this message instance using numpy for array types
        :param str: byte array of serialized message, ``str``
        :param numpy: numpy python module
        """
        if python3:
            codecs.lookup_error("rosmsg").msg_type = self._type
        try:
            if self.header is None:
                self.header = std_msgs.msg.Header()
            if self.top_destinations is None:
                self.top_destinations = None
            end = 0
            _x = self
            start = end
            end += 12
            (
                _x.header.seq,
                _x.header.stamp.secs,
                _x.header.stamp.nsecs,
            ) = _get_struct_3I().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
                self.header.frame_id = str[start:end].decode("utf-8", "rosmsg")
            else:
                self.header.frame_id = str[start:end]
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
                self.period = str[start:end].decode("utf-8", "rosmsg")
            else:
                self.period = str[start:end]
            start = end
            end += 4
            (self.total_interactions,) = _get_struct_I().unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            self.top_destinations = []
            for i in range(0, length):
                val1 = monitor_msgs.msg.DestinationStat()
                start = end
                end += 4
                (length,) = _struct_I.unpack(str[start:end])
                start = end
                end += length
                if python3:
                    val1.name = str[start:end].decode("utf-8", "rosmsg")
                else:
                    val1.name = str[start:end]
                start = end
                end += 4
                (val1.count,) = _get_struct_I().unpack(str[start:end])
                self.top_destinations.append(val1)
            _x = self
            start = end
            end += 12
            (
                _x.speech_recognition_rate,
                _x.average_interaction_time,
                _x.distance_traveled,
            ) = _get_struct_3f().unpack(str[start:end])
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e)  # most likely buffer underfill


_struct_I = genpy.struct_I


def _get_struct_I():
    global _struct_I
    return _struct_I


_struct_3I = None


def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I


_struct_3f = None


def _get_struct_3f():
    global _struct_3f
    if _struct_3f is None:
        _struct_3f = struct.Struct("<3f")
    return _struct_3f
